# 复杂度分析

**复杂度分析是整个算法学习的精髓，掌握了复杂度分析，数据结构和算法基本就掌握了一半。**

## 事后分析法

跑一遍代码，通过监控、统计得到代码执行的时间和占用的内存大小。这种方法得到的数据是准确的，但是有很大的局限性：

1. 测试结果很依赖环境，而环境恰好是不可控的。比如不同的处理器的执行结果肯定不一样，甚至同一台设备在不同时间执行的结果都有可能不一样。
2. 测试的结果受数据规模和数据本身的影响很大。比如数据本身已经是有序了的，那排序算法基本不需要做什么操作。有比如小规模的数据排序插入排序可能比快速排序还要快。

## 大 O 复杂度表示法

**表示代码执行时间、空间随数据规模增长的变化趋势。T<sub>(n)</sub>=O(f<sub>(n)</sub>)**

将执行时的时间和空间按照执行次（n)进行累加，再取最大量级的计算方式。

```
function f(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= n; j++) {
      sum = sum + i * j;
    }
  }
}
```

以上代码可以这样分析：

1. 假设每条语句的执行时间为 unit_time ;
2. 第二行执行了一遍，需要 1 个 unit_time 的时间；
3. 第三行执行了 n 遍，需要 n\*unit_time 的时间；
4. 第四、五行执行了代码 n<sup>2</sup> 次，需要 n<sup>2</sup>\*unit_time 的时间。
5. 所以整段代码的执行时间可以看作为 T<sub>(n)</sub>=n<sup>2</sup>\*unit_time + n\*unit_time + unit_time
6. 将 n 看做无限大，公式中的低阶、常数、系数等对执行时间的影响很小可以忽略不计，于是这段代码的执行时间可以看做 T<sub>(n)</sub> = O(n<sup>2</sup>)

### 时间复杂度分析

1. 只关注循环执行次数最多的一段代码
2. 加法法则，总复杂度等于量级最大的那段代码的复杂度。
3. 乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

复杂度量级可以粗略的分为多项式量级和非多项式量级

1. 多项式量级包含：常量阶 O(1)、对数阶 O(logn)、线性阶 O(n)、线性对数阶 O(nlogn)、平方阶 O(n<sup>2</sup>)、立方阶 O(n<sup>3</sup>)、...k 次方阶 O(n<sup>k</sup>)。
2. 非多项式量级包含：指数阶 O(2<sup>n</sup>)、阶乘阶 O(n!)

### 常用复杂度

1. O(1)
   <br> 一般情况下，只要算法中不存在循环语句、递归语句，即使成千上万行代码，其实复杂度都是 O(1)
2. O(logn)、O(nlogn)
